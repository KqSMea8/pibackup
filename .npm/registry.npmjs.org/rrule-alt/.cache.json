{"_id":"rrule-alt","_rev":"5-3f019753de73f3baa3c5df3e4fd88b88","name":"rrule-alt","description":"JavaScript library for working with recurrence rules for calendar dates.","dist-tags":{"latest":"2.2.5"},"versions":{"2.2.1":{"name":"rrule-alt","version":"2.2.1","description":"JavaScript library for working with recurrence rules for calendar dates.","homepage":"https://github.com/arolson101/rrule-alt","keywords":["dates","recurrences","calendar","icalendar","rfc"],"author":{"name":"Jakub Roztocil and Lars Schöning"},"main":"lib/rrule","types":"lib/rrule.d.ts","repository":{"type":"git","url":"git+https://github.com/arolson101/rrule-alt.git"},"scripts":{"test":"standard && mocha"},"devDependencies":{"mocha":"^3.2.0","standard":"^8.6.0"},"standard":{"ignore":["demo"]},"files":["lib","README.md"],"gitHead":"6e2ef755db3281eac25d754b0fd3e0c5034b141c","bugs":{"url":"https://github.com/arolson101/rrule-alt/issues"},"_id":"rrule-alt@2.2.1","_shasum":"d714b7e99b2016b3259a43e3a58d02d08ea4241d","_from":".","_npmVersion":"3.10.9","_nodeVersion":"7.0.0","_npmUser":{"name":"arolson101","email":"andrew@olsononline.org"},"maintainers":[{"name":"arolson101","email":"andrew@olsononline.org"}],"dist":{"shasum":"d714b7e99b2016b3259a43e3a58d02d08ea4241d","tarball":"https://registry.npmjs.org/rrule-alt/-/rrule-alt-2.2.1.tgz"},"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/rrule-alt-2.2.1.tgz_1482263325751_0.9327299855649471"},"directories":{}},"2.2.2":{"name":"rrule-alt","version":"2.2.2","description":"JavaScript library for working with recurrence rules for calendar dates.","homepage":"https://github.com/arolson101/rrule-alt","keywords":["dates","recurrences","calendar","icalendar","rfc"],"author":{"name":"Jakub Roztocil and Lars Schöning"},"main":"lib/rrule","types":"lib/rrule.d.ts","repository":{"type":"git","url":"git+https://github.com/arolson101/rrule-alt.git"},"scripts":{"test":"standard && mocha"},"devDependencies":{"mocha":"^3.2.0","standard":"^8.6.0"},"standard":{"ignore":["demo"]},"files":["lib","README.md"],"gitHead":"b6277fa81faf22f83b2e91b0f4fe06d1eab7b6e1","bugs":{"url":"https://github.com/arolson101/rrule-alt/issues"},"_id":"rrule-alt@2.2.2","_shasum":"e940488c01e0d83f936454b184f9b0d64004572b","_from":".","_npmVersion":"3.10.9","_nodeVersion":"7.0.0","_npmUser":{"name":"arolson101","email":"andrew@olsononline.org"},"maintainers":[{"name":"arolson101","email":"andrew@olsononline.org"}],"dist":{"shasum":"e940488c01e0d83f936454b184f9b0d64004572b","tarball":"https://registry.npmjs.org/rrule-alt/-/rrule-alt-2.2.2.tgz"},"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/rrule-alt-2.2.2.tgz_1482388415943_0.5571667635813355"},"directories":{}},"2.2.3":{"name":"rrule-alt","version":"2.2.3","description":"JavaScript library for working with recurrence rules for calendar dates.","homepage":"https://github.com/arolson101/rrule-alt","keywords":["dates","recurrences","calendar","icalendar","rfc"],"author":{"name":"Jakub Roztocil and Lars Schöning"},"main":"lib/rrule","types":"lib/rrule.d.ts","repository":{"type":"git","url":"git+https://github.com/arolson101/rrule-alt.git"},"scripts":{"test":"standard && mocha"},"devDependencies":{"mocha":"^3.2.0","standard":"^8.6.0"},"standard":{"ignore":["demo"]},"files":["lib","README.md"],"gitHead":"2249126c1627408b9e27df41ec1ecd3fbf64abca","bugs":{"url":"https://github.com/arolson101/rrule-alt/issues"},"_id":"rrule-alt@2.2.3","_shasum":"1ebd16fe01ee47e8bd09e4d6b8b9aa04adb5ccd6","_from":".","_npmVersion":"3.10.9","_nodeVersion":"7.0.0","_npmUser":{"name":"arolson101","email":"andrew@olsononline.org"},"maintainers":[{"name":"arolson101","email":"andrew@olsononline.org"}],"dist":{"shasum":"1ebd16fe01ee47e8bd09e4d6b8b9aa04adb5ccd6","tarball":"https://registry.npmjs.org/rrule-alt/-/rrule-alt-2.2.3.tgz"},"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/rrule-alt-2.2.3.tgz_1482388532390_0.21870196098461747"},"directories":{}},"2.2.4":{"name":"rrule-alt","version":"2.2.4","description":"JavaScript library for working with recurrence rules for calendar dates.","homepage":"https://github.com/arolson101/rrule-alt","keywords":["dates","recurrences","calendar","icalendar","rfc"],"author":{"name":"Jakub Roztocil and Lars Schöning"},"main":"lib/rrule","types":"lib/rrule.d.ts","repository":{"type":"git","url":"git+https://github.com/arolson101/rrule-alt.git"},"scripts":{"test":"standard && mocha"},"devDependencies":{"mocha":"^3.2.0","standard":"^8.6.0"},"standard":{"ignore":["demo"]},"files":["lib","README.md"],"gitHead":"02f4fb4b299408562a0cabd29107b91914f6b9ca","bugs":{"url":"https://github.com/arolson101/rrule-alt/issues"},"_id":"rrule-alt@2.2.4","_shasum":"927ef6190e37bf85f1e62409208fe8bfc27b4499","_from":".","_npmVersion":"3.10.9","_nodeVersion":"7.0.0","_npmUser":{"name":"arolson101","email":"andrew@olsononline.org"},"maintainers":[{"name":"arolson101","email":"andrew@olsononline.org"}],"dist":{"shasum":"927ef6190e37bf85f1e62409208fe8bfc27b4499","tarball":"https://registry.npmjs.org/rrule-alt/-/rrule-alt-2.2.4.tgz"},"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/rrule-alt-2.2.4.tgz_1485375748686_0.4345251922495663"},"directories":{}},"2.2.5":{"name":"rrule-alt","version":"2.2.5","description":"JavaScript library for working with recurrence rules for calendar dates.","homepage":"https://github.com/arolson101/rrule-alt","keywords":["dates","recurrences","calendar","icalendar","rfc"],"author":{"name":"Jakub Roztocil and Lars Schöning"},"main":"lib/rrule","types":"lib/rrule.d.ts","repository":{"type":"git","url":"git+https://github.com/arolson101/rrule-alt.git"},"scripts":{"test":"standard && mocha"},"devDependencies":{"mocha":"^3.2.0","standard":"^8.6.0"},"standard":{"ignore":["demo"]},"files":["lib","README.md"],"gitHead":"e863724b02013c74a1a4d4d25983863ced515955","bugs":{"url":"https://github.com/arolson101/rrule-alt/issues"},"_id":"rrule-alt@2.2.5","_shasum":"7e8c059997aae01b82e727c7dbf9d0d5ee716448","_from":".","_npmVersion":"3.10.8","_nodeVersion":"6.9.1","_npmUser":{"name":"arolson101","email":"andrew@olsononline.org"},"dist":{"shasum":"7e8c059997aae01b82e727c7dbf9d0d5ee716448","tarball":"https://registry.npmjs.org/rrule-alt/-/rrule-alt-2.2.5.tgz"},"maintainers":[{"name":"arolson101","email":"andrew@olsononline.org"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/rrule-alt-2.2.5.tgz_1487269718033_0.4711739239282906"},"directories":{}}},"readme":"rrule.js\r\n========\r\n\r\n**Library for working with recurrence rules for calendar dates.**\r\n\r\n[![NPM version][npm-image]][npm-url]\r\n[![Build Status][travis-image]][travis-url]\r\n[![js-standard-style][js-standard-image]][js-standard-url]\r\n[![Downloads][downloads-image]][downloads-url]\r\n\r\nrrule.js supports recurrence rules as defined in the [iCalendar\r\nRFC](http://www.ietf.org/rfc/rfc2445.txt), with a few important\r\n[differences](#differences-from-icalendar-rfc). It is a partial port of the\r\n`rrule` module from the excellent\r\n[python-dateutil](http://labix.org/python-dateutil/) library. On top of\r\nthat, it supports parsing and serialization of recurrence rules from and\r\nto natural language.\r\n\r\n**Notes**\r\nThis is a fork of [rrule](https://github.com/jkbrzt/rrule), which appears to have ceased development.\r\nI've ported the merge requests created there and will make only minor changes.  Should be a drop-in\r\nreplacement until development resumes.\r\n\r\n* * * * *\r\n\r\n\r\n### Quick Start\r\n\r\n-   [Demo app](http://jkbrzt.github.io/rrule/)\r\n\r\n#### Client Side\r\n\r\n```bash\r\n$ bower install rrule-alt\r\n```\r\n\r\nAlternatively, download\r\n[rrule.js](https://github.com/arolson101/rrule-alt/master/lib/rrule.js) manually. If\r\nyou intend to use `RRule.prototype.toText()` or `RRule.fromText()`, you'll\r\nalso need [nlp.js](https://github.com/arolson101/rrule-alt/master/lib/nlp.js).\r\n\r\n```html\r\n<script src=\"rrule-alt/lib/rrule.js\"></script>\r\n\r\n<!-- Optional -->\r\n<script src=\"rrule-alt/lib/nlp.js\"></script>\r\n```\r\n\r\n#### Server Side\r\n\r\n```bash\r\n$ npm install rrule-alt\r\n```\r\n\r\n```javascript\r\nvar RRule = require('rrule-alt').RRule\r\nvar RRuleSet = require('rrule-alt').RRuleSet\r\nvar rrulestr = require('rrule-alt').rrulestr\r\n```\r\n\r\n#### Usage\r\n\r\n**RRule:**\r\n```js\r\n// Create a rule:\r\nvar rule = new RRule({\r\n  freq: RRule.WEEKLY,\r\n  interval: 5,\r\n  byweekday: [RRule.MO, RRule.FR],\r\n  dtstart: new Date(2012, 1, 1, 10, 30),\r\n  until: new Date(2012, 12, 31)\r\n})\r\n\r\n// Get all occurrence dates (Date instances):\r\nrule.all()\r\n['Fri Feb 03 2012 10:30:00 GMT+0100 (CET)',\r\n 'Mon Mar 05 2012 10:30:00 GMT+0100 (CET)',\r\n 'Fri Mar 09 2012 10:30:00 GMT+0100 (CET)',\r\n 'Mon Apr 09 2012 10:30:00 GMT+0200 (CEST)',\r\n /* … */]\r\n\r\n// Get a slice:\r\nrule.between(new Date(2012, 7, 1), new Date(2012, 8, 1))\r\n['Mon Aug 27 2012 10:30:00 GMT+0200 (CEST)',\r\n 'Fri Aug 31 2012 10:30:00 GMT+0200 (CEST)']\r\n\r\n// Get an iCalendar RRULE string representation:\r\n// The output can be used with RRule.fromString().\r\nrule.toString()\r\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z;INTERVAL=5;UNTIL=20130130T230000Z;BYDAY=MO,FR\"\r\n\r\n// Get a human-friendly text representation:\r\n// The output can be used with RRule.fromText().\r\nrule.toText()\r\n\"every 5 weeks on Monday, Friday until January 31, 2013\"\r\n```\r\n\r\n**RRuleSet:**\r\n```js\r\nvar rruleSet = new RRuleSet()\r\n\r\n// Add a rrule to rruleSet\r\nrruleSet.rrule(new RRule({\r\n  freq: RRule.MONTHLY,\r\n  count: 5,\r\n  dtstart: new Date(2012, 1, 1, 10, 30)\r\n}))\r\n\r\n// Add a date to rruleSet\r\nrruleSet.rdate(new Date(2012, 6, 1, 10, 30))\r\n\r\n// Add another date to rruleSet\r\nrruleSet.rdate(new Date(2012, 6, 2, 10, 30))\r\n\r\n// Add a exclusion rrule to rruleSet\r\nrruleSet.exrule(new r.RRule({\r\n  freq: RRule.MONTHLY,\r\n  count: 2,\r\n  dtstart: new Date(2012, 2, 1, 10, 30)\r\n}))\r\n\r\n// Add a exclusion date to rruleSet\r\nrruleSet.exdate(new Date(2012, 5, 1, 10, 30))\r\n\r\n// Get all occurrence dates (Date instances):\r\nrruleSet.all()\r\n['Wed Feb 01 2012 10:30:00 GMT+0800 (CST)',\r\n 'Tue May 01 2012 10:30:00 GMT+0800 (CST)',\r\n 'Sun Jul 01 2012 10:30:00 GMT+0800 (CST)',\r\n 'Mon Jul 02 2012 10:30:00 GMT+0800 (CST)']\r\n\r\n// Get a slice:\r\nrruleSet.between(new Date(2012, 2, 1), new Date(2012, 6, 2))\r\n['Tue May 01 2012 10:30:00 GMT+0800 (CST)',\r\n 'Sun Jul 01 2012 10:30:00 GMT+0800 (CST)']\r\n\r\n // To string\r\nrruleSet.valueOf()\r\n['RRULE:FREQ=MONTHLY;COUNT=5;DTSTART=20120201T023000Z',\r\n 'RDATE:20120701T023000Z,20120702T023000Z',\r\n 'EXRULE:FREQ=MONTHLY;COUNT=2;DTSTART=20120301T023000Z',\r\n 'EXDATE:20120601T023000Z']\r\n\r\n// To string\r\nrruleSet.toString()\r\n'[\"RRULE:FREQ=MONTHLY;COUNT=5;DTSTART=20120201T023000Z\",\"RDATE:20120701T023000Z,20120702T023000Z\",\"EXRULE:FREQ=MONTHLY;COUNT=2;DTSTART=20120301T023000Z\",\"EXDATE:20120601T023000Z\"]'\r\n```\r\n\r\n**rrulestr:**\r\n```js\r\n// Parse a RRule string, return a RRule object\r\nrrulestr('RRULE:FREQ=MONTHLY;COUNT=5;DTSTART=20120201T023000Z')\r\n\r\n// Parse a RRule string, return a RRuleSet object\r\nrrulestr('RRULE:FREQ=MONTHLY;COUNT=5;DTSTART=20120201T023000Z', {forceset: true})\r\n\r\n// Parse a RRuleSet string, return a RRuleSet object\r\nrrulestr('RRULE:FREQ=MONTHLY;COUNT=5;DTSTART=20120201T023000Z\\nRDATE:20120701T023000Z,20120702T023000Z\\nEXRULE:FREQ=MONTHLY;COUNT=2;DTSTART=20120301T023000Z\\nEXDATE:20120601T023000Z')\r\n\r\n```\r\n\r\nFor more examples see\r\n[python-dateutil](http://labix.org/python-dateutil/) documentation.\r\n\r\n### API\r\n\r\n#### `RRule` Constructor\r\n\r\n```javascript\r\nnew RRule(options[, noCache=false])\r\n```\r\n\r\nThe `options` argument mostly corresponds to the properties defined for `RRULE` in the\r\niCalendar RFC. Only `freq` is required.\r\n\r\n<table>\r\n    <!-- why, markdown... -->\r\n    <thead>\r\n    <tr>\r\n        <th>Option</th>\r\n        <th>Description</th>\r\n    </tr>\r\n    <thead>\r\n    <tbody>\r\n    <tr>\r\n        <td><code>freq</code></td>\r\n        <td>\r\n            <p>(required) One of the following constants:</p>\r\n            <ul>\r\n                <li><code>RRule.YEARLY</code></li>\r\n                <li><code>RRule.MONTHLY</code></li>\r\n                <li><code>RRule.WEEKLY</code></li>\r\n                <li><code>RRule.DAILY</code></li>\r\n                <li><code>RRule.HOURLY</code></li>\r\n                <li><code>RRule.MINUTELY</code></li>\r\n                <li><code>RRule.SECONDLY</code></li>\r\n            </ul>\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>dtstart</code></td>\r\n        <td>The recurrence start. Besides being the base for the\r\n            recurrence, missing parameters in the final recurrence\r\n            instances will also be extracted from this date. If not\r\n            given, <code>new Date</code> will be used instead.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>interval</code></td>\r\n        <td>The interval between each freq iteration. For example,\r\n            when using <code>RRule.YEARLY</code>, an interval of <code>2</code> means\r\n            once every\r\n            two years, but with <code>RRule.HOURLY</code>, it means once every two\r\n            hours.\r\n            The default interval is <code>1</code>.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>wkst</code></td>\r\n        <td>The week start day. Must be one of the <code>RRule.MO</code>,\r\n            <code>RRule.TU</code>, <code>RRule.WE</code> constants, or an integer,\r\n            specifying\r\n            the first day of the week. This will affect recurrences based\r\n            on weekly periods. The default week start is <code>RRule.MO</code>.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>count</code></td>\r\n        <td>How many occurrences will be generated.</td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>until</code></td>\r\n        <td>If given, this must be a <code>Date</code> instance, that will specify\r\n            the limit of the recurrence. If a recurrence instance happens\r\n            to be the same as the <code>Date</code> instance given in the\r\n            <code>until</code>\r\n            argument, this will be the last occurrence.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>bysetpos</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, positive or negative. Each given integer will specify\r\n            an occurrence number, corresponding to the nth occurrence of\r\n            the rule inside the frequency period. For example, a\r\n            <code>bysetpos</code> of <code>-1</code> if combined with a <code>RRule.MONTHLY</code>\r\n            frequency, and a byweekday of (<code>RRule.MO</code>, <code>RRule.TU</code>,\r\n            <code>RRule.WE</code>, <code>RRule.TH</code>, <code>RRule.FR</code>), will result in\r\n            the last\r\n            work day of every month.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>bymonth</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the months to apply the recurrence to.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>bymonthday</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the month days to apply the recurrence to.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>byyearday</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the year days to apply the recurrence to.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>byweekno</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the week numbers to apply the recurrence to.\r\n            Week numbers have the meaning described in ISO8601, that is,\r\n            the first week of the year is that containing at least four\r\n            days of the new year.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>byweekday</code></td>\r\n        <td>If given, it must be either an integer (<code>0 == RRule.MO</code>), a\r\n            sequence of integers, one of the weekday constants\r\n            (<code>RRule.MO</code>,\r\n            <code>RRule.TU</code>, etc), or a sequence of these constants. When\r\n            given,\r\n            these variables will define the weekdays where the recurrence\r\n            will be applied. It's also possible to use an argument n for\r\n            the weekday instances, which will mean the nth occurrence of\r\n            this weekday in the period. For example, with\r\n            <code>RRule.MONTHLY</code>,\r\n            or with <code>RRule.YEARLY</code> and <code>BYMONTH</code>, using\r\n            <code>RRule.FR.nth(+1)</code> or <code>RRule.FR.nth(-1)</code> in <code>byweekday</code>\r\n            will specify the first or last friday of the month where the\r\n            recurrence happens.\r\n            Notice\r\n            that the RFC documentation, this is specified as <code>BYDAY</code>,\r\n            but was renamed to avoid the ambiguity of that argument.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>byhour</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the hours to apply the recurrence to.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>byminute</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the minutes to apply the recurrence to.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>bysecond</code></td>\r\n        <td>If given, it must be either an integer, or a sequence of\r\n            integers, meaning the seconds to apply the recurrence to.\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td><code>byeaster</code></td>\r\n        <td>This is an extension to the RFC specification which the Python\r\n            implementation provides.\r\n            <strong>Not implemented in the JavaScript version.</strong>\r\n        </td>\r\n    </tr>\r\n    </tbody>\r\n</table>\r\n\r\n\r\n`noCache`: Set to `true` to disable caching of results. If you will use the\r\nsame rrule instance multiple times, enabling caching will improve the\r\nperformance considerably. Enabled by default.\r\n\r\nSee also [python-dateutil](http://labix.org/python-dateutil/)\r\ndocumentation.\r\n\r\n\r\n* * * * *\r\n\r\n\r\n#### Instance properties\r\n\r\n<dl>\r\n    <dt><code>rule.options</code></dt>\r\n    <dd>Processed options applied to the rule. Includes default options\r\n    (such us <code>wkstart</code>). Currently,\r\n    <code>rule.options.byweekday</code> isn't equal\r\n    to <code>rule.origOptions.byweekday</code> (which is an inconsistency).\r\n    </dd>\r\n\r\n    <dt><code>rule.origOptions</code></dt>\r\n    <dd>The original <code>options</code> argument passed to\r\n    the constructor.</dd>\r\n</dl>\r\n\r\n\r\n* * * * *\r\n\r\n\r\n#### Occurrence Retrieval Methods\r\n\r\n##### `RRule.prototype.all([iterator])`\r\n\r\nReturns all dates matching the rule. It is a replacement for the\r\niterator protocol this class implements in the Python version.\r\n\r\nAs rules without `until` or `count` represent infinite date series, you\r\ncan optionally pass `iterator`, which is a function that is called for\r\neach date matched by the rule. It gets two parameters `date` (the `Date`\r\ninstance being added), and `i` (zero-indexed position of `date` in the\r\nresult). Dates are being added to the result as long as the iterator\r\nreturns `true`. If a `false`-y value is returned, `date` isn't added to\r\nthe result and the iteration is interrupted (possibly prematurely).\r\n\r\n```javascript\r\nrule.all()\r\n['Fri Feb 03 2012 10:30:00 GMT+0100 (CET)',\r\n 'Mon Mar 05 2012 10:30:00 GMT+0100 (CET)',\r\n 'Fri Mar 09 2012 10:30:00 GMT+0100 (CET)',\r\n 'Mon Apr 09 2012 10:30:00 GMT+0200 (CEST)',\r\n /* … */]\r\n\r\nrule.all(function (date, i){return i < 2})\r\n['Fri Feb 03 2012 10:30:00 GMT+0100 (CET)',\r\n 'Mon Mar 05 2012 10:30:00 GMT+0100 (CET)',]\r\n```\r\n\r\n##### `RRule.prototype.between(after, before, inc=false [, iterator])`\r\n\r\nReturns all the occurrences of the rrule between `after` and `before`.\r\nThe inc keyword defines what happens if `after` and/or `before` are\r\nthemselves occurrences. With `inc == true`, they will be included in the\r\nlist, if they are found in the recurrence set.\r\n\r\nOptional `iterator` has the same function as it has with\r\n`RRule.prototype.all()`.\r\n\r\n```javascript\r\nrule.between(new Date(2012, 7, 1), new Date(2012, 8, 1))\r\n['Mon Aug 27 2012 10:30:00 GMT+0200 (CEST)',\r\n 'Fri Aug 31 2012 10:30:00 GMT+0200 (CEST)']\r\n```\r\n\r\n##### `RRule.prototype.before(dt, inc=false)`\r\n\r\nReturns the last recurrence before the given `Date` instance. The `inc`\r\nargument defines what happens if `dt` is an occurrence. With\r\n`inc == true`, if `dt` itself is an occurrence, it will be returned.\r\n\r\n\r\n##### `RRule.prototype.after(dt, inc=false)`\r\n\r\nReturns the first recurrence\r\nafter the given `Date` instance. The `inc` argument defines what happens\r\nif `dt` is an occurrence. With `inc == true`, if `dt` itself is an\r\noccurrence, it will be returned.\r\n\r\nSee also [python-dateutil](http://labix.org/python-dateutil/)\r\ndocumentation.\r\n\r\n\r\n* * * * *\r\n\r\n\r\n#### iCalendar RFC String Methods\r\n\r\n##### `RRule.prototype.toString()`\r\n\r\nReturns a string representation of the rule as per the iCalendar RFC.\r\nOnly properties explicitly specified in `options` are included:\r\n\r\n```javascript\r\nrule.toString()\r\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z;INTERVAL=5;UNTIL=20130130T230000Z;BYDAY=MO,FR\"\r\n\r\nrule.toString() == RRule.optionsToString(rule.origOptions)\r\ntrue\r\n```\r\n\r\n##### `RRule.optionsToString(options)`\r\n\r\nConverts `options` to iCalendar RFC `RRULE` string:\r\n\r\n```javascript\r\n// Get full a string representation of all options,\r\n// including the default and inferred ones.\r\nRRule.optionsToString(rule.options)\r\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z;INTERVAL=5;WKST=0;UNTIL=20130130T230000Z;BYDAY=MO,FR;BYHOUR=10;BYMINUTE=30;BYSECOND=0\"\r\n\r\n// Cherry-pick only some options from an rrule:\r\nRRule.optionsToString({\r\n  freq: rule.options.freq,\r\n  dtstart: rule.options.dtstart\r\n})\r\n\"FREQ=WEEKLY;DTSTART=20120201T093000Z\"\r\n```\r\n\r\n##### `RRule.fromString(rfcString)`\r\n\r\nConstructs an `RRule` instance from a complete `rfcString`:\r\n\r\n```javascript\r\nvar rule = RRule.fromString(\"FREQ=WEEKLY;DTSTART=20120201T093000Z\")\r\n\r\n// This is equivalent\r\nvar rule = new RRule(RRule.parseString(\"FREQ=WEEKLY;DTSTART=20120201T093000Z\"))\r\n```\r\n\r\n##### `RRule.parseString(rfcString)`\r\n\r\nOnly parse RFC string and return `options`.\r\n\r\n```javascript\r\nvar options = RRule.parseString('FREQ=DAILY;INTERVAL=6')\r\noptions.dtstart = new Date(2000, 1, 1)\r\nvar rule = new RRule(options)\r\n```\r\n\r\n* * * * *\r\n\r\n#### Natural Language Text Methods\r\n\r\nThese methods provide an incomplete support for text–`RRule` and\r\n`RRule`–text conversion. You should test them with your input to see\r\nwhether the result is acceptable.\r\n\r\nTo use these methods in the browser, you need to include the\r\n`rrule/nlp.js` file as well.\r\n\r\n##### `RRule.prototype.toText([gettext, [language]])`\r\n\r\nReturns a textual representation of `rule`. The `gettext` callback, if\r\nprovided, will be called for each text token and its return value used\r\ninstead. The optional `language` argument is a language definition to be\r\nused (defaults to `rrule/nlp.js:ENGLISH`).\r\n\r\n```javascript\r\nvar rule = new RRule({\r\n  freq: RRule.WEEKLY,\r\n  count: 23\r\n})\r\nrule.toText()\r\n\"every week for 23 times\"\r\n```\r\n\r\n##### `RRule.prototype.isFullyConvertibleToText()`\r\n\r\nProvides a hint on whether all the options the rule has are convertible\r\nto text.\r\n\r\n##### `RRule.fromText(text[, language])`\r\n\r\nConstructs an `RRule` instance from `text`.\r\n\r\n```javascript\r\nrule = RRule.fromText('every day for 3 times')\r\n```\r\n\r\n##### `RRule.parseText(text[, language])`\r\n\r\nParse `text` into `options`:\r\n\r\n```javascript\r\noptions = RRule.parseText('every day for 3 times')\r\n// {freq: 3, count: \"3\"}\r\noptions.dtstart = new Date(2000, 1, 1)\r\nvar rule = new RRule(options)\r\n```\r\n\r\n\r\n* * * * *\r\n\r\n#### `RRuleSet` Constructor\r\n\r\n```javascript\r\nnew RRuleSet([noCache=false])\r\n```\r\n\r\nThe RRuleSet instance allows more complex recurrence setups, mixing multiple\r\n rules, dates, exclusion rules, and exclusion dates.\r\n\r\nDefault `noCache` argument is `false`, caching of results will be enabled,\r\nimproving performance of multiple queries considerably.\r\n\r\n##### `RRuleSet.prototype.rrule(rrule)`\r\n\r\nInclude the given rrule instance in the recurrence set generation.\r\n\r\n##### `RRuleSet.prototype.rdate(dt)`\r\nInclude the given datetime instance in the recurrence set generation.\r\n\r\n##### `RRuleSet.prototype.exrule(rrule)`\r\nInclude the given rrule instance in the recurrence set exclusion list. Dates\r\nwhich are part of the given recurrence rules will not be generated, even if\r\nsome inclusive rrule or rdate matches them.\r\n\r\n##### `RRuleSet.prototype.exdate(dt)`\r\nInclude the given datetime instance in the recurrence set exclusion list. Dates\r\nincluded that way will not be generated, even if some inclusive rrule or\r\nrdate matches them.\r\n\r\n##### `RRuleSet.prototype.all([iterator])`\r\n\r\nSame as `RRule.prototype.all`.\r\n\r\n##### `RRuleSet.prototype.between(after, before, inc=false [, iterator])`\r\n\r\nSame as `RRule.prototype.between`.\r\n\r\n##### `RRuleSet.prototype.before(dt, inc=false)`\r\n\r\nSame as `RRule.prototype.before`.\r\n\r\n##### `RRuleSet.prototype.after(dt, inc=false)`\r\n\r\nSame as `RRule.prototype.after`.\r\n\r\n* * * * *\r\n\r\n#### `rrulestr` Function\r\n\r\n```js\r\nrrulestr(rruleStr[, options])\r\n```\r\n\r\nThe `rrulestr` function is a parser for RFC-like syntaxes. The string passed\r\nas parameter may be a multiple line string, a single line string, or just the\r\nRRULE property value.\r\n\r\nAdditionally, it accepts the following keyword arguments:\r\n\r\n`cache`\r\nIf True, the rruleset or rrule created instance will cache its results.\r\nDefault is not to cache.\r\n\r\n`dtstart`\r\nIf given, it must be a datetime instance that will be used when no DTSTART\r\nproperty is found in the parsed string. If it is not given, and the property\r\nis not found, datetime.now() will be used instead.\r\n\r\n`unfold`\r\nIf set to True, lines will be unfolded following the RFC specification. It\r\ndefaults to False, meaning that spaces before every line will be stripped.\r\n\r\n`forceset`\r\nIf set to True a rruleset instance will be returned, even if only a single rule\r\nis found. The default is to return an rrule if possible, and an rruleset if necessary.\r\n\r\n`compatible`\r\nIf set to True, the parser will operate in RFC-compatible mode. Right now it\r\nmeans that unfold will be turned on, and if a DTSTART is found, it will be\r\nconsidered the first recurrence instance, as documented in the RFC.\r\n\r\n`ignoretz`\r\nIf set to True, the date parser will ignore timezone information available in\r\nthe DTSTART property, or the UNTIL attribute.\r\n\r\n`tzinfos`\r\nIf set, it will be passed to the datetime string parser to resolve unknown\r\ntimezone settings. For more information about what could be used here, check\r\nthe parser documentation.\r\n\r\n* * * * *\r\n\r\n### Differences From iCalendar RFC\r\n\r\n* `RRule` has no `byday` keyword. The equivalent keyword has been replaced by\r\nthe `byweekday` keyword, to remove the ambiguity present in the original\r\nkeyword.\r\n* Unlike documented in the RFC, the starting datetime, `dtstart`, is\r\nnot the first recurrence instance, unless it does fit in the specified rules.\r\nThis is in part due to this project being a port of\r\n[python-dateutil](https://labix.org/python-dateutil#head-a65103993a21b717f6702063f3717e6e75b4ba66),\r\nwhich has the same non-compliant functionality. Note that you can get the\r\noriginal behavior by using a `RRuleSet` and adding the `dtstart` as an `rdate`.\r\n\r\n```javascript\r\nvar rruleSet = new RRuleSet()\r\nvar start = new Date(2012, 1, 1, 10, 30)\r\n\r\n// Add a rrule to rruleSet\r\nrruleSet.rrule(new RRule({\r\n  freq: RRule.MONTHLY,\r\n  count: 5,\r\n  dtstart: start\r\n}))\r\n\r\n// Add a date to rruleSet\r\nrruleSet.rdate(start)\r\n```\r\n\r\n* Unlike documented in the RFC, every keyword is valid on every frequency (the\r\nRFC documents that `byweekno` is only valid on yearly frequencies, for example).\r\n\r\n### Development\r\n\r\nrrule.js use [JavaScript Standard Style](https://github.com/feross/standard) coding style.\r\n\r\n### Changelog\r\n* 2.2.0-dev\r\n    * Added support `RRuleSet`, which allows more complex recurrence setups,\r\n      mixing multiple rules, dates, exclusion rules, and exclusion dates.\r\n    * Added Millisecond precision\r\n        * Millisecond offset extracted from `dtstart` (`dtstart.getTime() % 1000`)\r\n        * Each recurrence is returned with the same offset\r\n    * Added some NLP support for hourly and byhour.\r\n    * Fixed export in nlp.js.\r\n* 2.1.0\r\n   * Removed dependency on Underscore.js (thanks, @gsf).\r\n   * Various small bugfixes and improvements.\r\n* 2.0.1\r\n   * Added bower.json.\r\n* 2.0.0 (2013-07-16)\r\n   * Fixed a February 28-related issue.\r\n   * More flexible, backwards-incompatible API:\r\n      * `freq` is now `options.freq`.\r\n      * `options.cache` is now `noCache`.\r\n      * `iterator` has to return `true`\r\n      * `dtstart` and `options` arguments removed from `RRule.fromString`\r\n        (use `RRule.parseString` and modify `options` manually instead).\r\n      * `today` argument removed from `Rule.prototype.toText`\r\n        (never actually used).\r\n      * `rule.toString()` now includes `DTSTART` (if explicitly specified\r\n        in `options`).\r\n      * Day constants `.clone` is now `.nth`, eg. `RRule.FR.nth(-1)`\r\n        (last Friday).\r\n   * Added `RRule.parseString`\r\n   * Added `RRule.parseText`\r\n   * Added `RRule.optionsToString`\r\n* 1.1.0 (2013-05-21)\r\n   * Added a [demo app](http://jkbrzt.github.io/rrule/).\r\n   * Handle dates in `UNTIL` in `RRule.fromString`.\r\n   * Added support for RequireJS.\r\n   * Added `options` argument to `RRule.fromString`.\r\n* 1.0.1 (2013-02-26)\r\n   * Fixed leap years (thanks @jessevogt)\r\n* 1.0.0 (2013-01-24)\r\n   * Fixed timezone offset issues related to DST (thanks @evro).\r\n* 1.0.0-beta (2012-08-15)\r\n   * Initial public release.\r\n\r\n\r\n#### Authors\r\n\r\n* [Jakub Roztocil](http://roztocil.co/)\r\n    ([@jkbrzt](http://twitter.com/jkbrzt))\r\n* Lars Schöning ([@lyschoening](http://twitter.com/lyschoening))\r\n\r\nPython `dateutil` is written by [Gustavo\r\nNiemeyer](http://niemeyer.net/).\r\n\r\nSee [LICENCE](https://github.com/jkbrzt/rrule/blob/master/LICENCE) for\r\nmore details.\r\n\r\n[npm-url]: https://npmjs.org/package/rrule-alt\r\n[npm-image]: http://img.shields.io/npm/v/rrule-alt.svg\r\n\r\n[travis-url]: https://travis-ci.org/arolson101/rrule-alt\r\n[travis-image]: http://img.shields.io/travis/arolson101/rrule-alt.svg\r\n\r\n[downloads-url]: https://npmjs.org/package/rrule-alt\r\n[downloads-image]: http://img.shields.io/npm/dm/rrule-alt.svg?style=flat-square\r\n\r\n[js-standard-url]: https://github.com/feross/standard\r\n[js-standard-image]: https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat\r\n","maintainers":[{"name":"arolson101","email":"andrew@olsononline.org"}],"time":{"modified":"2017-02-16T18:28:39.955Z","created":"2016-12-20T19:48:48.029Z","2.2.1":"2016-12-20T19:48:48.029Z","2.2.2":"2016-12-22T06:33:36.750Z","2.2.3":"2016-12-22T06:35:34.604Z","2.2.4":"2017-01-25T20:22:29.562Z","2.2.5":"2017-02-16T18:28:39.955Z"},"homepage":"https://github.com/arolson101/rrule-alt","keywords":["dates","recurrences","calendar","icalendar","rfc"],"repository":{"type":"git","url":"git+https://github.com/arolson101/rrule-alt.git"},"author":{"name":"Jakub Roztocil and Lars Schöning"},"bugs":{"url":"https://github.com/arolson101/rrule-alt/issues"},"readmeFilename":"README.md","_attachments":{},"_etag":"W/\"58a5ef57-8038\"","_lastModified":"Thu, 16 Feb 2017 18:28:39 GMT"}